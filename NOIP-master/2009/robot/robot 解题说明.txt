首先这是一道最优解, 所以很明显是动态规划. 但本题的难度明显高于普通的背包问题.

如果我们知道在第i时间且正好在第j路段能得到的最多金币，记为f(i,j), 则答案即为
max{f(m, j) | j = 1 ... n}.

我们把在第i时间能得到的最多金币数记为fmax[i], 显然:
fmax(i) = max {f(i,j) | j = 1 ... n};

f(i, j) = max {fmax(i-k) + 
               coin(i-k)(j-k) + coin(i-k+1)(j-k+1) +...+coin(i)(j) - 
               cost(j-k) | 1 <= k <= p }
即, robot在j路段时有可能已经走了1步, 2步,...或p步. 如果走了k步，则在第j-k路段
买了机器人，并搜集了沿途的金币。当然在第i-k时间，他应该取得最大值。

考虑coin(i-k)(j-k) + coin(i-k+1)(j-k+1) +...+coin(i)(j)，如果我们将
.....2......
......2.....
.......1....
........1...
.........1..

我们可以将这些数字预先按加起来
.....2......
......4.....
.......5....
........6...
.........7..
则coin(3,8)+coin(4,9)+coin(5,10) ==> coin'(5,10) - coin'(2,7)

所以， 
f(i,j) = coin'(i,j) + max {fmax(i-k) - coin'(i-k)(j-k) - cost (j-k) | 1 <= k <=p};
令
g(i,j) = max {fmax(i-k) - coin'(i-k)(j-k) - cost (j-k) | 1 <= k <=p};



